var documenterSearchIndex = {"docs":
[{"location":"theory/#Theory","page":"Theory","title":"Theory","text":"MMF NEXUS is an algorithm for the identification of cosmic web environments. Clusters (nodes), filaments, sheets (walls), and voids are found in scale space to preserve the multiscale nature of the large scale distributions of matter. This packages concerns specifically the NEXUS+ procedure which computes the filtering in logarithmic space. \n\nThe algorithm is outlined by the following steps:\n\nApply a gaussian filter with scale R_n to the input field.\nCompute the eigenvalues of the Hessian matrix of the filtered field.\nCompute signatures for each environment for each voxel of the density field.\nRepeat the steps above for a number of different filtering scales.\nFind the optimal environment signature, independant of scale.\nUse a detection threshhold based on physical criteria.\n\nThe environments are found hyrarchically, in the sense that first nodes are detected, then filaments, then walls, and anything not identified is considered a void. This is done as, for example, typically nodes have both a strong node and filament siganture, etc.\n\nBelow we elaborate on each step. This theory section is paraphrasiing the detailed explanation found in the original NEXUS publication","category":"section"},{"location":"theory/#Filtering","page":"Theory","title":"Filtering","text":"The gaussian filter of width R_n is applied in Fourier space. First for node identification, this is done on the density field f(bmx),\n\nf_n(bmx) = int fracd^3k(2pi)^3e^-k^2R_n^22 hatf(bmk)e^ibmkcdotbmx\n\nwhere hatf(bmk) is the fourier transform of the input field and f_n(bmx) is the filtered field. This is used for the input field when calculating the node signatures. They turn out to perform much worse when using the NEXUS+ procedure of filtering in logarithmic space.\n\nFor the signature calculations of the other environments, the log of the field f is first computed,\n\ng = log_10f\n\nand then smoothed with a gaussian filter,\n\ng_n(bmx) = int fracd^3k(2pi)^3e^-k^2R_n^22 hatg(bmk)e^ibmkcdotbmx\n\nwhere hatg(bmk) is the fourier transform of the logarithm of the input field and g_n(bmx) is the logarithmic filtered field. To obtain the lograithmically filtered field, we exponantiate and renormalize the resulting field such that the mean remains the same as the input field,\n\nf_n(bmx) = C_n 10^g_n\n\nwhere C_n is the renormalization constant.\n\nUsually, filtering is done over a range of scales naturally seperated as:\n\nR_n = (sqrt2)^n R_0\n\nwhere R_0 is the minimum filtering scale and n is choosen to be a range of integers. Typical values are R_0 = 05 Mpch and n = 0 ldots 6.","category":"section"},{"location":"theory/#Signature-calculations","page":"Theory","title":"Signature calculations","text":"With this we can compute the Hessian of the the field for each voxel. The hessian is defined as,\n\nbeginequation\n    H_ij(bmxR_n) = R_n^2 fracpartial^2 f_n(bmx)partial x_i partial x_j\nendequation\n\nThis is also computed in Fourier space. the Hessian eigenvalues are calculated as,\n\ndet(H(bmxR_n) - lambda I) = 0\n\nwhere lambda are the eigenvalues. The eigenvalues are ordered as lambda_1 leq lambda_2 leq lambda_3.\n\nWith this, we find the morphological signature for each environment,\n\nmathcalS(bmx R_n) = begincases\nfraclambda_3^2lambda_1 theta(-lambda_1) theta(-lambda_2) theta(-lambda_3)  textnode \nfraclambda_2^2lambda_1 Thetaleft(1 - fraclambda_3lambda_1 right) theta(-lambda_1) theta(-lambda_2)  textfilament \nlambda_1 Thetaleft(1 - fraclambda_2lambda_1 right) Thetaleft(1 - fraclambda_3lambda_1 right) theta(-lambda_1)  textwall\nendcases\n\nwhere Theta(x) = x theta(x) and theta(x) is the Heaviside step function. This classification is based on the insights of Zel'dovich 1970 and Hahn et al. 2007 on the geometry of the matter distribution based on the eigenvalues of the Hessian.\n\nThen, for each point, the signature is choosen for the scale where the signature is maximum,\n\nmathcalS(bmx) = max_n mathcalS(bmx R_n)\n\nwhich is a scale independant signature.","category":"section"},{"location":"theory/#Detection-thresholds","page":"Theory","title":"Detection thresholds","text":"For nodes, the threshold is determined by considering the fraction of valid nodes given the average density contrast contained in the identified nodes as a function of the signature threshold. This is done by identifying all clumps of adjacent voxels above a certain signature threshold as individual nodes. Then, the average density of each clump is calculated and compared to a given average density Delta often taken as Delta = 370. Increasing the cluster signature threshold will monotonically increase the fraction of valid nodes from near 0 to 1. The optimal threshold is then chosen as the signature corresponding to 50% valid nodes. In addition to this, we only consider nodes that contain a mass of at least 10^13 M_odot to avoid spurious detections.\n\nFilament and wall detection thresholds are determined by considering the change in mass contained in filaments/walls as a function of signature threshold. This is given by,\n\nDelta M^2 = left fracdM^2dlog S right \n\nwhere M is the mass contained in filaments/walls and S the signature threshold. The optimal signature threshold is then chosen as the signature corresponding to the peak in Delta M^2. An additional requirement for the minimum volume of filaments and walls is chosen to be 1 (textMpch)^3 and 2 (textMpch)^3, respectively.","category":"section"},{"location":"theory/#Variations","page":"Theory","title":"Variations","text":"Discuss \"Normal\" NEXUS, shear, etc.","category":"section"},{"location":"citations/#Citations","page":"citations","title":"Citations","text":"","category":"section"},{"location":"#MMF-NEXUS","page":"Home","title":"MMF NEXUS","text":"Documentation for MMFNEXUS.\n\nUNDER DEVELOPMENT\n\nThis is the Julia implementation for the NEXUS+ algorithm. More information and standalone application can be found on our website in the future.","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"<!– The Multiscale Morphology Filter (MMF) NEXUS can be installed with the Julia package manager. From the Pkg Repl mode run:\n\nadd pkg thing in julia –>\n\nFor now, the Multiscale Morphology Filter (MMF) NEXUS can not be installed through the package manager yet. This will become available soon.","category":"section"},{"location":"#Usage","page":"Home","title":"Usage","text":"For now, the NEXUS+ algorithm is the only routine available. This requries a density field with non-zero values everywhere. For optimal results, we suggest density field reconstructions using DTFE, or Phase-Space DTFE. On how to reconstruct a density field from a particle distribution is found on the respective pages. The density field should be normalized, i.e. fracrhorho_textmean = 1 + delta.\n\nGive the normalized density field (densityField), we identify the cosmic web environments as follows:\n\nusing MMFNEXUS\n\n# field and box parameters (example from the reconstruction of the illustris-3 box sampled at 256^3)\nN = 256 # number of gridpoints per dimension\nL = 75. # Box size in cMpc/h\ntotalMass = 4e8 * 455^3 # total mass contained in simulation box in Msun/h \n\n# NEXUS+ parameters\nminimumFilterScale = 0.5 # minimum smoothing scale in Mpc/h\nfilter_scales = 6 # maximum index n in min_scale*(√2)^n. Here it does n = 0,1,2,3,4,5,6\ndensity_contrast_node = 370.\nminimum_node_mass = 1e13 # Msun/h\nminimum_filament_volume = 5 # (MPC/h)^3\nminimum_wall_volume = 5 # (MPC/h)^3\n\nMMF_node, MMF_filament, MMF_wall, MMF_void = NEXUS_Plus(densityField, N, L, totalMass, filter_scales, density_contrast_node, minimum_node_mass, minimum_filament_volume, minimum_wall_volume; R0 = min_scale);\n\n\nThe resulting MMF_* outputs are BitArray's of size (N,N,N) where for each voxel, one of the morphological environments has the value 1 and all others are 0 to indicate to which environment it belongs.\n\nFor more details, theory, and a tutorial, please consult the Documentation.","category":"section"},{"location":"#Contributors","page":"Home","title":"Contributors","text":"This Julia implementation was written by:\n\nBram Alferink (alferink@astro.rug.nl)\n\nThe original NEXUS+ algorithm published as NEXUS: tracing the cosmic web connection (Marius Cautun , Rien van de Weygaert , Bernard J. T. Jones) was written by:\n\nMarius Cautun\n\nWe thank:\n\nIvan Spirov\nRien van de Weijgaert","category":"section"},{"location":"tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"In this tutorial, we demonstrate how to use MMF NEXUS on a density field. The density field used in this example is obtained from using Phase Space DTFE on the particle distributino of a 64^3 GADGET-4 simulation. \n\nIn principle MMF NEXUS can be applied to any continous density field. Due to the filtering in log space, NEXUS+ requires the field to be positive valued everywhere. We suggest to use DTFE or Phase Space DTFE for the density field reconstructions as those methods preserve the geometric properties of the matter distribution and are positive valued at each point.\n\nWe now start by importing relevant libraries and loading the data:\n\nusing MMFNEXUS, HDF5, Statistics\n\n# Load test density field\nfunction load_data(file)\n    fid = h5open(file, \"r\")\n    densityfield = read(fid[\"densityfield\"])\n    close(fid)\n\n    densityfield = densityfield ./ mean(densityfield)\n    return densityfield\nend\n\ndensityfield = load_data(\"assets/data/densityfield.h5\");\nnothing\n\n\nlets do a plot here\n\n# set up the box\nN = 64\nL = 50. #Mpc/h\nM = 4.075161606358443e10 * 64^3 # total mass contained in the box in in Msun\n\n# set NEXUS+ parameters\nmin_scale = .5 #minimum smoothing scale in Mpc/h\nfilter_scales = 6 #max n in min_scale*(√2)^n, starting at n=0\ndensity_contrast_node = 370.\nmin_node_mass = 1e13 #Msun/h\nmin_fila_volume = 10 #(Mpc/h)^3\nmin_wall_volume = 10 #(Mpc/h)^3\nnothing\n\n\ncalculation here. etc.","category":"section"},{"location":"tutorial/#Options","page":"Tutorial","title":"Options","text":"","category":"section"},{"location":"tutorial/#Multithreading","page":"Tutorial","title":"Multithreading","text":"","category":"section"}]
}
