var documenterSearchIndex = {"docs":
[{"location":"theory/#Theory","page":"Theory","title":"Theory","text":"MMF NEXUS is an algorithm for the identification of cosmic web environments. Clusters (nodes), filaments, sheets (walls), and voids are found in scale space to preserve the multiscale nature of the large scale distributions of matter. This packages concerns specifically the NEXUS+ procedure which computes the filtering in logarithmic space. \n\nThe algorithm is outlined by the following steps:\n\nApply a gaussian filter with scale R_n to the input field.\nCompute the eigenvalues of the Hessian matrix of the filtered field.\nCompute signatures for each environment for each voxel of the density field.\nRepeat the steps above for a number of different filtering scales.\nFind the optimal environment signature, independant of scale.\nUse a detection threshhold based on physical criteria.\n\nThe environments are found hyrarchically, in the sense that first nodes are detected, then filaments, then walls, and anything not identified is considered a void. This is done as, for example, typically nodes have both a strong node and filament siganture, etc.\n\nBelow we elaborate on each step. This theory section is paraphrasiing the detailed explanation found in the original NEXUS publication.","category":"section"},{"location":"theory/#Filtering","page":"Theory","title":"Filtering","text":"The gaussian filter of width R_n is applied in Fourier space. First for node identification, this is done on the density field f(bmx),\n\nf_n(bmx) = int fracd^3k(2pi)^3e^-k^2R_n^22 hatf(bmk)e^ibmkcdotbmx\n\nwhere hatf(bmk) is the fourier transform of the input field and f_n(bmx) is the filtered field. This is used for the input field when calculating the node signatures. They turn out to perform much worse when using the NEXUS+ procedure of filtering in logarithmic space.\n\nFor the signature calculations of the other environments, the log of the field f is first computed,\n\ng = log_10f\n\nand then smoothed with a gaussian filter,\n\ng_n(bmx) = int fracd^3k(2pi)^3e^-k^2R_n^22 hatg(bmk)e^ibmkcdotbmx\n\nwhere hatg(bmk) is the fourier transform of the logarithm of the input field and g_n(bmx) is the logarithmic filtered field. To obtain the lograithmically filtered field, we exponantiate and renormalize the resulting field such that the mean remains the same as the input field,\n\nf_n(bmx) = C_n 10^g_n\n\nwhere C_n is the renormalization constant.\n\nUsually, filtering is done over a range of scales naturally seperated as:\n\nR_n = (sqrt2)^n R_0\n\nwhere R_0 is the minimum filtering scale and n is choosen to be a range of integers. Typical values are R_0 = 05 Mpch and n = 0 ldots 6.","category":"section"},{"location":"theory/#Signature-calculations","page":"Theory","title":"Signature calculations","text":"With this we can compute the Hessian of the the field for each voxel. The hessian is defined as,\n\nbeginequation\n    H_ij(bmxR_n) = R_n^2 fracpartial^2 f_n(bmx)partial x_i partial x_j\nendequation\n\nThis is also computed in Fourier space. the Hessian eigenvalues are calculated as,\n\ndet(H(bmxR_n) - lambda I) = 0\n\nwhere lambda are the eigenvalues. The eigenvalues are ordered as lambda_1 leq lambda_2 leq lambda_3.\n\nWith this, we find the morphological signature for each environment,\n\nmathcalS(bmx R_n) = begincases\nfraclambda_3^2lambda_1 theta(-lambda_1) theta(-lambda_2) theta(-lambda_3)  textnode \nfraclambda_2^2lambda_1 Thetaleft(1 - fraclambda_3lambda_1 right) theta(-lambda_1) theta(-lambda_2)  textfilament \nlambda_1 Thetaleft(1 - fraclambda_2lambda_1 right) Thetaleft(1 - fraclambda_3lambda_1 right) theta(-lambda_1)  textwall\nendcases\n\nwhere Theta(x) = x theta(x) and theta(x) is the Heaviside step function. This classification is based on the insights of Zel'dovich 1970 and Hahn et al. 2007 on the geometry of the matter distribution based on the eigenvalues of the Hessian.\n\nThen, for each point, the signature is choosen for the scale where the signature is maximum,\n\nmathcalS(bmx) = max_n mathcalS(bmx R_n)\n\nwhich is a scale independant signature.","category":"section"},{"location":"theory/#Detection-thresholds","page":"Theory","title":"Detection thresholds","text":"For nodes, the threshold is determined by considering the fraction of valid nodes given the average density contrast contained in the identified nodes as a function of the signature threshold. This is done by identifying all clumps of adjacent voxels above a certain signature threshold as individual nodes. Then, the average density of each clump is calculated and compared to a given average density Delta often taken as Delta = 370. Increasing the cluster signature threshold will monotonically increase the fraction of valid nodes from near 0 to 1. The optimal threshold is then chosen as the signature corresponding to 50% valid nodes. In addition to this, we only consider nodes that contain a mass of at least 10^13 M_odot to avoid spurious detections.\n\nFilament and wall detection thresholds are determined by considering the change in mass contained in filaments/walls as a function of signature threshold. This is given by,\n\nDelta M^2 = left fracdM^2dlog S right \n\nwhere M is the mass contained in filaments/walls and S the signature threshold. The optimal signature threshold is then chosen as the signature corresponding to the peak in Delta M^2. An additional requirement for the minimum volume of filaments and walls is chosen to be 1 (textMpch)^3 and 2 (textMpch)^3, respectively.","category":"section"},{"location":"theory/#Variations","page":"Theory","title":"Variations","text":"There are a number of other routines that find signatures of different fields such the tidal field, the velocity divergence, the velocity shear, the logdensity field (this is not the same as NEXUS+ which only applies the filter in log space). As of now, none of those are implemented in this package but may be added in the future. More information is found in the original NEXUS publication.","category":"section"},{"location":"citations/#Citations","page":"citations","title":"Citations","text":"","category":"section"},{"location":"#MMF-NEXUS","page":"Home","title":"MMF NEXUS","text":"Documentation for MMFNEXUS.\n\nUNDER DEVELOPMENT\n\nThis is the Julia implementation for the NEXUS+ algorithm. More information and standalone application can be found on our website in the future.","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"<!– The Multiscale Morphology Filter (MMF) NEXUS can be installed with the Julia package manager. From the Pkg Repl mode run:\n\nadd pkg thing in julia –>\n\nFor now, the Multiscale Morphology Filter (MMF) NEXUS can not be installed through the package manager yet. This will become available soon.","category":"section"},{"location":"#Usage","page":"Home","title":"Usage","text":"The basic usage of the NEXUS+ routine requries a density field with non-zero values everywhere. For optimal results, we suggest density field reconstructions using DTFE, or Phase-Space DTFE. How to reconstruct a density field from a particle distribution is found on the respective pages. The density field should be normalized, i.e. fracrhorho_textmean = 1 + delta.\n\nGive the normalized density field (densityField), we identify the cosmic web environments as follows:\n\nusing MMFNEXUS\n\n# field and box parameters (example from the reconstruction of the illustris-3 box sampled at 256^3)\nN = 256 # number of gridpoints per dimension\nL = 75. # Box size in cMpc/h\ntotalMass = 4e8 * 455^3 # total mass contained in simulation box in Msun/h \n\nMMF_node, MMF_filament, MMF_wall, MMF_void = NEXUS_Plus(densityField, N, L, totalMass);\n\n\nThe resulting MMF_* outputs are BitArray's of size (N,N,N) where for each voxel, one of the morphological environments has the value 1 and all others are 0 to indicate to which environment it belongs. There are a number of optinal settings which are discussed in the tutorial section of the documentation.","category":"section"},{"location":"#Contributors","page":"Home","title":"Contributors","text":"This Julia implementation is written by:\n\nBram Alferink (alferink@astro.rug.nl)\n\nThe original NEXUS+ algorithm published as NEXUS: tracing the cosmic web connection (Marius Cautun , Rien van de Weygaert , Bernard J. T. Jones) is written by:\n\nMarius Cautun\n\nWe thank:\n\nIvan Spirov\nRien van de Weijgaert\nJob Feldbrugge","category":"section"},{"location":"tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"In this tutorial, we demonstrate how to use MMF NEXUS on a density field. The density field used in this example is obtained from using Phase Space DTFE on the particle distributino of a 64^3 GADGET-4 simulation. \n\nIn principle MMF NEXUS can be applied to any continous density field. Due to the filtering in log space, NEXUS+ requires the field to be positive valued everywhere. We suggest to use DTFE or Phase Space DTFE for the density field reconstructions as those methods preserve the geometric properties of the matter distribution and are positive valued at each point.\n\nWe now start by importing relevant libraries and loading the data. We plot a slice of the density field to illustrate what we are working with.\n\nusing MMFNEXUS, HDF5, Statistics, Plots\n\n# Load test density field\nfunction load_data(file)\n    fid = h5open(file, \"r\")\n    densityfield = read(fid[\"densityfield\"])\n    close(fid)\n\n    densityfield = densityfield ./ mean(densityfield)\n    return densityfield\nend\n\ndensityfield = load_data(\"assets/data/densityfield.h5\");\nheatmap(log10.(densityfield[:, :, 20]), aspect_ratio=:equal, c=:viridis, title=\"Density Field Slice\", xlabel=\"x [Mpc/h]\", ylabel=\"y [Mpc/h]\", colorbar_title=\"log₁₀(1+δ)\", xlims=(0, 50), ylims=(0, 50), xticks=0:10:50, yticks=0:10:50);\n\n\n\nWe now set up the simulation box.\n\n# set up the box\nN = 64 # number of voxels per side\nL = 50. # side length in Mpc/h\nM = 4.075e10 * 64^3 # total mass contained in the box in in Msun\n\n\nThe NEXUS+ routine is called with the function NEXUS_Plus, which takes the density field and a number of keyword arguments. These will be explained below. One of the keyword arguments is a verbose level which can be set to none, info, or debug. info gives some basic information on what the calulation is doing. debug gives additional information and figures of the threshold calulation to see what is going on. NEXUS_Plus gives four boolean matrices where for each environemt a 1 means the voxel is considered to be in the corresponding environemnt\n\nMMF_node, MMF_fila, MMF_wall, MMF_void = NEXUS_Plus(densityfield, N, L, M; filter_parse = 6 ,R0 = .5, level = :info);\nnothing\n\nWe can use the result to plot the contours on top of the slice of a density field, which we show below, or any subsequent analysis.\n\nslice_index = 20\nheatmap(log10.(densityfield[:, :, slice_index]), aspect_ratio=:equal, c=:viridis, title=\"Density Field Slice\", xlabel=\"x [Mpc/h]\", ylabel=\"y [Mpc/h]\", colorbar_title=\"log₁₀(1+δ)\", xlims=(0, 50), ylims=(0, 50), xticks=0:10:50, yticks=0:10:50)\ncontour!(MMF_wall[:, :, slice_index], levels=[0.5], color=:green, linewidth=2, label=\"Walls\")\ncontour!(MMF_fila[:, :, slice_index], levels=[0.5], color=:blue, linewidth=2, label=\"Filaments\")\ncontour!(MMF_node[:, :, slice_index], levels=[0.5], color=:red, linewidth=2, label=\"Nodes\")\n","category":"section"},{"location":"tutorial/#Options","page":"Tutorial","title":"Options","text":"A number of parameters can be changed manually in NEXUS+. Particularly the minimum filtering scale can be changed according to the resolution of the simulation and corresponding density field. The keyword arguments and their defaults of NEXUS_Plus are: \n\nΔ::Real = 370. # density contrast for node detection\nmin_node_mass::Real = 1e13 # minimum mass of a node in Msun/h\nmin_fila_volume::Real = 10 # minimum volume of a filament in (Mpc/h)^3\nmin_wall_volume::Real = 10 # minimum volume of a wall in (Mpc/h)^3\nR0::Real = 1. #minimum smoothing scale in Mpc/h\nfilter_parse = 4 #max n in min_scale*(√2)^n, starting at n=0\nlevel::Symbol = :info # verbose level\n\nΔ is the density contrast for node detection, this is further explained in the theory section. The minimum node mass is used as a physical selection criteria to avoid spurious detections of tiny dense clumps as clusters. Similarly,the minimum fila/wall argument is used to avoid spurious detections. R0 is the minimum filtering scale. Filter parse takes either an integer, in which case the filter scales are R0(√2)^n where n are integers from 0 up to the given integer, or a tuple/array of all the user defined scales in Mpc/h can be given directly. In case a tuple is given, the argument R0 does not do anything. The level parameter lets us select the verbose level which can be set to none, info, or debug. info gives some basic information on what the calulation is doing. debug gives additional information and figures of the threshold calulation to see what is going on.\n\nThe function with all keyword arguments can be called as:\n\nMMF_node, MMF_filament, MMF_wall, MMF_void = NEXUS_Plus(densityField, N, L, totalMass; filter_parse = filter_parse, Δ = Δ, min_node_mass = min_node_mass, min_fila_volume = min_fila_volume, minimum_wall_volume = min_wall_volume; R0 = R0, level = level);","category":"section"},{"location":"tutorial/#Multithreading","page":"Tutorial","title":"Multithreading","text":"Multithreading is automatically enabled. It will utilize the cores available to your instance of Julia. This can be set by opening julia with a specifified number of threads:\n\n$ julia --threads 4\n\nto open julia with 4 threads for example or by setting an environment variable. For more information, see the corresponding multi-threading documentation.","category":"section"}]
}
